
; patch
to-report p-is-portal?
  report any? portals-here
end

; patch 
to-report p-portal-accesses-portals
  let source-portal one-of portals-here
  let accessible-portals []
  if source-portal != nobody [
    ask source-portal [
      set accessible-portals access-neighbors
    ]
  ]
  report accessible-portals
end 

; patch
to-report p-portal-findables-portals
  let source-portal one-of portals-here
  let findable-portals []
  if source-portal != nobody [
    ask source-portal [
      let p-portal-findables findable-neighbors
      set findable-portals p-portal-findables with [is-portal? self]
    ] 
  ]
  report findable-portals
end

; patch
to-report p-platform-neighbors [nodes]
  let neighbor-nodes 0
  ifelse p-is-portal? [
    let portal-node one-of portals-here
      print" try"
    set neighbor-nodes other nodes with [
      p-platform = [p-platform] of myself
      or
      member? portal-node p-portal-accesses-portals
    ]
  ]
  [
    set neighbor-nodes nodes with [
      p-platform = [p-platform] of myself 
    ]
  ]
  report other neighbor-nodes
end 

; patch 
to-report p-distance-platform [destination-p]
  let _distance 0
  ifelse p-platform = [p-platform] of destination-p [
    ; normal pathfind
    show "normal pathfind"
    let path p-pathfind self destination-p
    set _distance distance-path path
  ][
    let source-portal one-of portals-here
    let destination-portal one-of [portals-here] of destination-p
    ask source-portal [
      set _distance [p-cost] of access-with destination-portal
    ]
  ]
  report _distance
end

;to-report distance-portals [p1 p2]
;  let _distance-portal 0
;  ask p1 [
;  let portal-link access-with p2
;    ifelse portal-access != nobody [
;      set _distance-portal [p-cost] of portal-access
;    ]
;    [
;      set portal-link findable-with p2
;      
;    ]
;  ]
;end

; observer 
to reset-p-platform-pathfind
  ask meta-pois [die]
  ask pathables [die]
end
; observer
; TODO test
to-report p-platform-pathfind [start-node goal-node]
  ; print "#############"
  reset-show-paths
  reset-p-platform-pathfind
  let open-set []
  let nodes patches with [
    p-is-portal? 
    or 
    self = start-node
    or 
    self = goal-node
  ] 
  
  
  ask nodes [
    sprout-meta-pois 1 []
  ]
  
  ask meta-pois[
    let this-meta-poi self
    let other-meta-pois other meta-pois
;    set meta-g-score 0
;    set meta-parent 0
;    set open-set fput self open-set
    ask patch-here [
      let this-patch self
      ifelse p-is-portal?[
        let this-portal one-of portals-here
        let accessible-portals p-portal-accesses-portals
        ask accessible-portals [
          let portal-access access-with this-portal
          let portal-access-cost [p-cost] of portal-access
          let portal-access-path (list ( [patch-here] of this-portal ) ( [patch-here] of self) )
          ask one-of meta-pois-here [
            create-pathable-with this-meta-poi [
              set pathable-cost portal-access-cost
              set pathable-path portal-access-path
              set color [0 255 255]
            ]  
          ]
        ]
        
        let findable-portals p-portal-findables-portals
        ask findable-portals [
          let portal-findable findable-with this-portal
          let portal-findable-cost [f-cost] of portal-findable
          let portal-findable-path [f-path] of portal-findable
          ask one-of meta-pois-here [
            create-pathable-with this-meta-poi [
              set pathable-cost portal-findable-cost
              set pathable-path portal-findable-path
              set color [0 255 255]
            ]   
          ]
        ]
      ]
      [
        ask other-meta-pois with [[p-platform] of [patch-here] of self = [p-platform] of this-patch] [
          let path p-pathfind this-patch [patch-here] of self 
          ;          let p-platform-meta-poi one-of [portals-here] of p-platform-neighbor-node
          ;          if p-platform-meta-poi = nobody [
          ;            set p-platform-meta-poi  one-of [meta-pois-here] of p-platform-neighbor-node
          ;          ]
          let normalized-path normalize-path path
          let normalized-path-cost distance-path normalized-path
          ;          show (list p-platform-meta-poi p-platform-neighbor-node)
          create-pathable-with this-meta-poi [
            set pathable-path normalized-path
            set pathable-cost normalized-path-cost
            set color [0 255 255]
          ]
        ]
      ]
    ]
  ]
  ;        ask p-portal-accesses-portals [ 
  ;        ]
  ;        ask 
  ;        ask other meta-pois with [[p-is-portal?] of patch-here] [
  ;          let other-portal one-of [portals-here] of patch-here
;          ask other-portal [
;            show (list "other this" other-portal this-portal)
;            let other-access-cost [p-cost] of access-with this-portal
;            create-pathable-with this-portal [
;              set pathable-cost other-access-cost
;            ]  
;          ]
;        ]
;      ]
;    ]
;    [
;      ; get findables to all others in same platform
;      let p-platform-neighbors-nodes [self] of p-platform-neighbors nodes
;      show (list "neighbornodes" p-platform-neighbors-nodes)
;      foreach p-platform-neighbors-nodes [ p-platform-neighbor-node ->
;        let path p-pathfind patch-here p-platform-neighbor-node
;        let p-platform-meta-poi one-of [portals-here] of p-platform-neighbor-node
;        if p-platform-meta-poi = nobody [
;          set p-platform-meta-poi  one-of [meta-pois-here] of p-platform-neighbor-node
;        ]
;        let normalized-path normalize-path path
;        let normalized-path-cost distance-path normalized-path
;        show (list p-platform-meta-poi p-platform-neighbor-node)
;        create-pathable-with p-platform-meta-poi [
;          set pathable-cost normalized-path-cost
;          set color [0 255 255]
;        ]
;      ]
;    ] 
;  ]
  
  ask nodes [ 
    set g-score infinity
    set parent 0
    set open-set fput self open-set
  ]
  
  ask start-node [
    set g-score 0
  ]
  
  reset-show-paths
  let index -1
  while [not empty? open-set ] [
    set index index + 1
    let current-node first sort-by [[t1 t2] -> [g-score] of t1 < [g-score] of t2] open-set
    ask current-node [sprout-debugers 1 [set color black]] ; DEBUG
    
    ; show (list "index" index "node" current-node)
    if current-node = goal-node [
;      show "found"
;      ask goal-node [        show (list "goal-node says" parent g-score)      ] ;debug
      
      let meta-path backtrace-path start-node goal-node
      
      let composed-path []
      let meta-path-length length meta-path
      let meta-path-index 0
      show (list "mounting found meta-path" )
      repeat meta-path-length - 1[
        let from-in-meta-path item meta-path-index meta-path
        let to-in-meta-path item ( meta-path-index + 1 ) meta-path
        show  (list "patches" from-in-meta-path "->" to-in-meta-path)
        let from-meta-poi one-of [meta-pois-here] of from-in-meta-path
        let to-meta-poi one-of [meta-pois-here] of to-in-meta-path
        show  (list "meta-pois" from-meta-poi "->" to-meta-poi )
        ask from-meta-poi [
          let pathable-from-to pathable-with to-meta-poi
          let pathable-from-to-path [pathable-path] of pathable-from-to
          show (list "pathable" pathable-from-to "path" pathable-from-to-path)
          if first pathable-from-to-path != from-in-meta-path [
            ; reverse
            set pathable-from-to-path reverse pathable-from-to-path 
          ]
          set composed-path fput pathable-from-to-path composed-path 
        ]
        set meta-path-index meta-path-index + 1
      ]
      
      report composed-path
    ]
    
    set open-set (remove current-node open-set)
    ;    show (list "open-set" open-set)
    
    
    
    ask current-node [
      let current-poi one-of [meta-pois-here] of current-node
      let neighbor-meta-pois [pathable-neighbors] of current-poi
      let neighbor-nodes [patch-here] of neighbor-meta-pois
      let not-explored-neighbor-nodes filter [x -> member? x neighbor-nodes] open-set
;      show (list "neighbors" neighbor-nodes "not-explored" not-explored-neighbor-nodes)
      foreach not-explored-neighbor-nodes [ x -> 
        ask x [
          ask one-of meta-pois-here[ 
            let pathable-edge pathable-with current-poi
            let edge-distance [pathable-cost] of pathable-edge
            let alt [g-score] of current-node + edge-distance
;            show (list "edge-distance" edge-distance "alt" alt)
            if alt < g-score [
              set g-score alt
              set parent current-node
            ]
          ]
        ]
      ]
    ]
    
    ;    ask current-node [
    ;      let platform-neighbor-nodes p-platform-neighbors nodes
;      let not-explored-neighbor-nodes filter [x -> member? x platform-neighbor-nodes] open-set
;      show (list "neighbors" platform-neighbor-nodes "not-explored" not-explored-neighbor-nodes)
;      foreach not-explored-neighbor-nodes [ x -> 
;        ask x [
;          let edge-distance p-distance-platform current-node ; TODO change
;          let alt [g-score] of current-node + edge-distance
;          show (list "edge-distance" edge-distance "alt" alt)
;          if alt < g-score [
;            set g-score alt
;            set parent current-node
;          ]
;        ]
;      ]
;    ]
  ]
;  show "empty"
  report []
  
end