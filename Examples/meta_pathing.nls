
; patch
to-report p-is-portal?
  report any? portals-here
end

; patch 
to-report p-portal-accesses-portals
  let source-portal one-of portals-here
  let accessible-portals []
  if source-portal != nobody [
    ask source-portal [
      set accessible-portals access-neighbors
    ]
  ]
  report accessible-portals
end 

; patch
to-report p-portal-findables-portals
  let source-portal one-of portals-here
  let findable-portals []
  if source-portal != nobody [
    ask source-portal [
      let p-portal-findables findable-neighbors
      set findable-portals p-portal-findables with [is-portal? self]
    ] 
  ]
  report findable-portals
end

; patch
to-report p-platform-neighbors [nodes]
  let neighbor-nodes 0
  ifelse p-is-portal? [
    let portal-node one-of portals-here
    print" try"
    set neighbor-nodes other nodes with [
      p-platform = [p-platform] of myself
      or
      member? portal-node p-portal-accesses-portals
    ]
  ]
  [
    set neighbor-nodes nodes with [
      p-platform = [p-platform] of myself 
    ]
  ]
  report other neighbor-nodes
end 

; patch 
; to-report p-distance-platform [destination-p]
;   let _distance 0
;   ifelse p-platform = [p-platform] of destination-p [
;     ; normal pathfind
;     show "normal pathfind"
;     let path p-pathfind-better self destination-p
;     set _distance distance-path path
;   ][
;     let source-portal one-of portals-here
;     let destination-portal one-of [portals-here] of destination-p
;     ask source-portal [
;       set _distance [p-cost] of access-with destination-portal
;     ]
;   ]
;   report _distance
; end

;to-report distance-portals [p1 p2]
;  let _distance-portal 0
;  ask p1 [
;  let portal-link access-with p2
;    ifelse portal-access != nobody [
;      set _distance-portal [p-cost] of portal-access
;    ]
;    [
;      set portal-link findable-with p2
;      
;    ]
;  ]
;end

; observer 
to reset-p-platform-pathfind
  ask meta-pois [die]
  ask pathables [die]
end
; observer
; TODO test
to-report p-platform-pathfind [start-node goal-node]
  reset-show-paths
  
  ; SETUP
  reset-p-platform-pathfind
  let open-set []
  let nodes patches with [
    p-is-portal? 
    or 
    self = start-node
    or 
    self = goal-node
  ] 
  
  
  ask nodes [
    sprout-meta-pois 1 []
  ]
  
  
  ask meta-pois [
    let this-meta-poi self
    let this-patch patch-here
    let this-platform [p-platform] of patch-here
    
    let this-portal one-of portals-here
    
    ifelse this-portal != nobody [
      ; We are a portal
      
      ; Create findables to other accessible portals
      let accessible-portals [access-neighbors] of this-portal 
      ask accessible-portals [
        let other-meta-poi one-of meta-pois-here
        if out-findable-to this-meta-poi = nobody [
          ; no need for duplicating calculations since access paths are symmetrical (just teleport)
          let portal-access access-with this-portal
          let portal-access-cost [p-cost] of portal-access
          let portal-access-path (list ( [patch-here] of this-portal ) ( [patch-here] of self) )
          ask other-meta-poi [
            create-pathable-from this-meta-poi [ ; from this-meta-poi to other-meta-poi
              set pathable-path portal-access-path
              set pathable-cost portal-access-cost
              set color [0 255 255]
            ]
            create-pathable-to this-meta-poi [ ; from other-meta-poi to this-meta-poi
              set pathable-path reverse portal-access-path
              set pathable-cost portal-access-cost 
              set color [0 255 255]
            ]
          ]
        ]
      ]
      
      ; Create findables to other portals in the platform
      ; Just the out direction from this-meta-poi
      let findable-portals ( ( [out-findable-neighbors] of this-portal ) with [any? portals-here] )
      ; show (list "findable portals are " findable-portals)
      ask findable-portals [
        let other-meta-poi one-of meta-pois-here
        let portable-findable in-findable-from this-portal
        let portal-findable-cost [f-cost] of portable-findable
        let portal-findable-path [f-path] of portable-findable
        ask other-meta-poi [
          create-pathable-from this-meta-poi [
            set pathable-path portal-findable-path
            set pathable-cost portal-findable-cost
            set color [0 255 255]
          ]
        ]
      ]      
    ]
    
    
    [
      ; We are the source or destination
      let other-meta-pois other meta-pois
      ask other-meta-pois with [[p-platform] of [patch-here] of self = this-platform] [
        let out-pathables-to-this-meta-poi out-pathable-to this-meta-poi
        
        
        (ifelse this-patch = start-node [
          let from-to-path p-pathfind-straightened this-patch [patch-here] of self 
          let path from-to-path 
          ; set path normalize-path path
          
          let path-cost distance-path path
          
          
          create-pathable-from this-meta-poi [ ; from this-meta-poi to other-meta-poi
            set pathable-path path
            set pathable-cost path-cost
            set color [0 255 255]
          ] 
          ]
          this-patch = goal-node [
            let to-from-path p-pathfind-straightened [patch-here] of self this-patch
            let path to-from-path 
            
            ; set path normalize-path to-from-path
            
            let path-cost distance-path path
            create-pathable-to this-meta-poi [ ; from other-meta-poi to this-meta-poi
              set pathable-path path
              set pathable-cost path-cost
              set color [0 255 255]
            ] 
          ]
          [
            error (word "Meta pathing " start-node "->" goal-node ": " this-patch " is not start or goal")
          ]
        )
        ; ifelse out-pathable-to this-meta-poi = nobody [    
        ;  ; Patches in different platforms
        ;  if this-patch = start-node
        ;  if this-patch
        ;  let from-to-path p-pathfind-straightened this-patch [patch-here] of self 
        ;  let normalized-from-to-path normalize-path from-to-path
        ;  let normalized-from-to-path-cost distance-path normalized-from-to-path
        ;  
        ;  let to-from-path p-pathfind-straightened [patch-here] of self this-patch
        ;  let normalized-to-from-path normalize-path to-from-path
        ;  let normalized-to-from-path-cost distance-path normalized-to-from-path
        ;  ;          show (list p-platform-meta-poi p-platform-neighbor-node)
        ;  create-pathable-from this-meta-poi [ ; from this-meta-poi to other-meta-poi
        ;    set pathable-path normalized-from-to-path
        ;    set pathable-cost normalized-from-to-path-cost
        ;    set color [0 255 255]
        ;  ] 
        ;  create-pathable-to this-meta-poi [ ; from other-meta-poi to this-meta-poi
        ;    set pathable-path normalized-to-from-path
        ;    set pathable-cost normalized-to-from-path-cost
        ;    set color [0 255 255]
        ;  ]   
        ; ]
        ; [
        ;   ; Source and destination are on the same platform and already pathfound
        ;   ; print (list "soruce and destiantion on the same platform" start-node goal-node)
        ; ]
        
      ]
      
    ]
  ]
  
  ask nodes [ 
    set g-score infinity
    set parent 0
    set open-set fput self open-set
  ]
  
  ask start-node [
    set g-score 0
  ]
  
  reset-show-paths ; DEBUG
  
  ; print (list "before running" map [ x -> (list x [g-score] of x) ] open-set)
  ; RUNNING
  let index -1
  while [not empty? open-set ] [
    set index index + 1
    let current-node first sort-by [[t1 t2] -> [g-score] of t1 < [g-score] of t2] open-set
    ask current-node [sprout-debugers 1 [set color black]] ; DEBUG
    
    ; print (list "open-set" map [x -> (list x [g-score] of x)] sort-by [[x y] -> [g-score] of x < [g-score] of y] open-set)
    ; show (list "index" index "node" current-node)
    if current-node = goal-node [
      ; show "found"
      ; ask goal-node [        
      ; show (list "goal-node says" parent g-score)      ] ;debug
      
      let meta-path backtrace-path start-node goal-node
      
      let composed-path []
      let meta-path-length length meta-path
      let meta-path-index 0
      ; show (list "mounting found meta-path" )
      repeat meta-path-length - 1  [
        let from-in-meta-path item meta-path-index meta-path
        let to-in-meta-path item ( meta-path-index + 1 ) meta-path
        ; show  (list "patches" from-in-meta-path "->" to-in-meta-path)
        let from-meta-poi one-of [meta-pois-here] of from-in-meta-path
        let to-meta-poi one-of [meta-pois-here] of to-in-meta-path
        ; show  (list "meta-pois" from-meta-poi "->" to-meta-poi )
        ask from-meta-poi [
          let pathable-from-to out-pathable-to to-meta-poi
          let pathable-from-to-path [pathable-path] of pathable-from-to
          ; show (list "pathable" pathable-from-to "path" pathable-from-to-path)
          if first pathable-from-to-path != from-in-meta-path [
            ; reverse
            set pathable-from-to-path reverse pathable-from-to-path 
          ]
          set composed-path lput pathable-from-to-path composed-path 
        ]
        set meta-path-index meta-path-index + 1
      ]
      report composed-path
    ]
    
    set open-set (remove current-node open-set)
    
    
    
    ask current-node [
      let current-poi one-of [meta-pois-here] of current-node
      let neighbor-meta-pois [out-pathable-neighbors] of current-poi
      let neighbor-nodes [patch-here] of neighbor-meta-pois
      let not-explored-neighbor-nodes filter [x -> member? x neighbor-nodes] open-set
      ; show (list "neighbors" neighbor-nodes "not-explored" not-explored-neighbor-nodes)
      foreach not-explored-neighbor-nodes [ x -> 
        ask x [
          ask one-of meta-pois-here[ 
            let pathable-edge in-pathable-from current-poi
            let edge-distance [pathable-cost] of pathable-edge
            let alt [g-score] of current-node + edge-distance
            ; show (list current-node "->" x "edge-distance" edge-distance "alt" alt "pathable-edge" pathable-edge)
            if alt < g-score [
              set g-score alt
              set parent current-node
            ]
          ]
        ]
      ]
    ]
    
  ]
  ;  show "empty"
  report []
  
end