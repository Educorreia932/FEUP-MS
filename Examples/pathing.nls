; observer
to init-path-finding
  init-portals-pathfinding
  init-floors-pathfinding
end

; observer
to init-portals-pathfinding 
  
  ask portals [
    let p-a1 self
    let connected-portals other portals with [
      tfloor-x = [tfloor-x] of myself
      and 
      tfloor-y =  [tfloor-y] of myself
    ]
    ask connected-portals [
      create-access-with p-a1 [
        set a1 p-a1
        set a2 myself
        set p-cost 0 
        set color red 
      ] 
    ]
  ]
end

; observer
to init-floors-pathfinding
  let platforms-index 0
  repeat PLATFORMS [
    let path-found-turtles []
    let poi-turtles turtles with [member? tt TTS-PATHABLE and t-platform = platforms-index]
    let poi-turtles-with-no-paths poi-turtles with [init-poi-paths = false]
    while [count poi-turtles-with-no-paths > 0 ][
      ask one-of poi-turtles-with-no-paths[
        let left-to-pathfind-to [self] of other poi-turtles-with-no-paths
        let index 0
        foreach left-to-pathfind-to [
          let goal item index left-to-pathfind-to
          let path pathfind goal
          let normalized-path normalize-path path
          let normalized-path-cost distance-path normalized-path
          set poi-paths lput path poi-paths
          create-findable-with goal [
            set f1 myself
            set f2 goal
            set f-path normalized-path
            set f-cost normalized-path-cost
            set f-p-id platforms-index
            set color green
          ]
          
          set index index + 1
        ]
        set init-poi-paths true
      ]
      set poi-turtles-with-no-paths poi-turtles with [init-poi-paths = false]
    ]
    set platforms-index platforms-index + 1
  ]
end

; observer
to-report adjacent [p1 p2]
  let p1-neighbors []
  ask p1 [
    set p1-neighbors neighbors
  ]
  report member? p2 p1-neighbors
end

; patch
to-report h-distance [destination-patch]
  report distance destination-patch
end

; patch
to-report is-pathable
  report not empty? filter [i -> member? i PTS-PATHABLE] pts
end

; observer
to-report backtrace-path [start-vertex goal-vertex]
  let path []
  let current-vertex goal-vertex
  while [current-vertex != 0] [
    set path fput current-vertex path
    set current-vertex [parent] of current-vertex
  ]
  if first path != start-vertex [
    report [] 
  ]
  report path
end

; turtle
to-report pathfind [pathfind-to]
  ask debugers [die]
  let start-vertex patch-here
  let goal-vertex [patch-here] of pathfind-to
  report p-pathfind start-vertex goal-vertex
end

; observer
to-report p-pathfind [start-vertex goal-vertex]
  ask patches with [is-pathable] [
    set g-score infinity
    set h-score h-distance goal-vertex
    set f-score (g-score + h-score)
    set parent 0
  ]
  
  let open-set (list start-vertex)
  let closed-set []
  ask start-vertex [
    set g-score 0
    set f-score h-score
  ]
  
  while [length open-set > 0 ] [
    let current-vertex first sort-by[[t1 t2] -> [f-score] of t1 < [f-score] of t2] open-set
    
;    ask current-vertex [sprout-debugers 1 [set color black]] ; DEBUG
    
    if current-vertex = goal-vertex [ ; Goal reached
      let path backtrace-path start-vertex goal-vertex
      report path
    ]
    
    set open-set (remove current-vertex open-set)
    set closed-set lput current-vertex closed-set
    
    ask current-vertex [
      let pathable-neighbors neighbors with [
        is-pathable
      ]
;      ask pathable-neighbors
      ask neighbors with [is-pathable] ; BUG for some reason it's not working with the variable?
      [
        if not member? self closed-set [
          let tentative-g [g-score] of current-vertex + distance current-vertex
          if not member? self open-set or tentative-g < g-score [
            set g-score tentative-g
            set f-score h-score + g-score
            set parent current-vertex
            if not member? self open-set [
              set open-set lput self open-set
            ]
          ]
        ]
      ]
    ]
  ]
  show (list "couldn't find" start-vertex goal-vertex)
  report []
end

; patch
to-report p-is-portal?
  report any? portals-here
end

; patch 
to-report p-portal-accesses-portals
  let source-portal one-of portals-here
  let accessible-portals []
  if source-portal != nobody [
    ask source-portal [
      set accessible-portals access-neighbors
    ]
  ]
  report accessible-portals
end 

; patch
to-report p-portal-findables-portals
  let source-portal one-of portals-here
  let findable-portals []
  if source-portal != nobody [
    ask source-portal [
      let p-portal-findables findable-neighbors
      set findable-portals p-portal-findables with [is-portal? self]
    ] 
  ]
  report findable-portals
end

; patch
to-report p-platform-neighbors [nodes]
  let neighbor-nodes 0
  ifelse p-is-portal? [
    let portal-node one-of portals-here
      print" try"
    set neighbor-nodes other nodes with [
      p-platform = [p-platform] of myself
      or
      member? portal-node p-portal-accesses-portals
    ]
  ]
  [
    set neighbor-nodes nodes with [
      p-platform = [p-platform] of myself 
    ]
  ]
  report other neighbor-nodes
end 

; patch 
to-report p-distance-platform [destination-patch]
  let _distance 0
  ifelse p-platform = [p-platform] of destination-patch [
    ; normal pathfind
    show "normal pathfind"
    let path p-pathfind self destination-patch
    set _distance distance-path path
  ][
    let source-portal one-of portals-here
    let destination-portal one-of [portals-here] of destination-patch
    ask source-portal [
      set _distance [p-cost] of access-with destination-portal
    ]
  ]
  report _distance
end

;to-report distance-portals [p1 p2]
;  let _distance-portal 0
;  ask p1 [
;  let portal-link access-with p2
;    ifelse portal-access != nobody [
;      set _distance-portal [p-cost] of portal-access
;    ]
;    [
;      set portal-link findable-with p2
;      
;    ]
;  ]
;end

; observer 
to reset-p-platform-pathfind
  ask meta-pois [die]
  ask pathables [die]
end
; observer
; TODO test
to-report p-platform-pathfind [start-node goal-node]
  ; print "#############"
  reset-show-paths
  reset-p-platform-pathfind
  let open-set []
  let nodes patches with [
    p-is-portal? 
    or 
    self = start-node
    or 
    self = goal-node
  ] 
  
  
  ask nodes [
    sprout-meta-pois 1 []
  ]
  
  ask meta-pois[
    let this-meta-poi self
    let other-meta-pois other meta-pois
;    set meta-g-score 0
;    set meta-parent 0
;    set open-set fput self open-set
    ask patch-here [
      let this-patch self
      ifelse p-is-portal?[
        let this-portal one-of portals-here
        let accessible-portals p-portal-accesses-portals
        ask accessible-portals [
          let portal-access access-with this-portal
          let portal-access-cost [p-cost] of portal-access
          ask one-of meta-pois-here [
            create-pathable-with this-meta-poi [
              set pathable-cost portal-access-cost
              set color [0 255 255]
            ]  
          ]
        ]
        
        let findable-portals p-portal-findables-portals
        ask findable-portals [
          let portal-findable findable-with this-portal
          let portal-findable-cost [f-cost] of portal-findable
          ask one-of meta-pois-here [
            create-pathable-with this-meta-poi [
              set pathable-cost portal-findable-cost
              set color [0 255 255]
            ]   
          ]
        ]
      ]
      [
        ask other-meta-pois with [[p-platform] of [patch-here] of self = [p-platform] of this-patch] [
          let path p-pathfind this-patch [patch-here] of self
          ;          let p-platform-meta-poi one-of [portals-here] of p-platform-neighbor-node
          ;          if p-platform-meta-poi = nobody [
          ;            set p-platform-meta-poi  one-of [meta-pois-here] of p-platform-neighbor-node
          ;          ]
          let normalized-path normalize-path path
          let normalized-path-cost distance-path normalized-path
          ;          show (list p-platform-meta-poi p-platform-neighbor-node)
          create-pathable-with this-meta-poi [
            set pathable-cost normalized-path-cost
            set color [0 255 255]
          ]
        ]
      ]
    ]
  ]
;        ask p-portal-accesses-portals [ 
;        ]
;        ask 
;        ask other meta-pois with [[p-is-portal?] of patch-here] [
;          let other-portal one-of [portals-here] of patch-here
;          ask other-portal [
;            show (list "other this" other-portal this-portal)
;            let other-access-cost [p-cost] of access-with this-portal
;            create-pathable-with this-portal [
;              set pathable-cost other-access-cost
;            ]  
;          ]
;        ]
;      ]
;    ]
;    [
;      ; get findables to all others in same platform
;      let p-platform-neighbors-nodes [self] of p-platform-neighbors nodes
;      show (list "neighbornodes" p-platform-neighbors-nodes)
;      foreach p-platform-neighbors-nodes [ p-platform-neighbor-node ->
;        let path p-pathfind patch-here p-platform-neighbor-node
;        let p-platform-meta-poi one-of [portals-here] of p-platform-neighbor-node
;        if p-platform-meta-poi = nobody [
;          set p-platform-meta-poi  one-of [meta-pois-here] of p-platform-neighbor-node
;        ]
;        let normalized-path normalize-path path
;        let normalized-path-cost distance-path normalized-path
;        show (list p-platform-meta-poi p-platform-neighbor-node)
;        create-pathable-with p-platform-meta-poi [
;          set pathable-cost normalized-path-cost
;          set color [0 255 255]
;        ]
;      ]
;    ] 
;  ]
  
  ask nodes [ 
    set g-score infinity
    set parent 0
    set open-set fput self open-set
  ]
  
  ask start-node [
    set g-score 0
  ]
  
  reset-show-paths
  let index -1
  while [not empty? open-set ] [
    set index index + 1
    let current-node first sort-by [[t1 t2] -> [g-score] of t1 < [g-score] of t2] open-set
    ask current-node [sprout-debugers 1 [set color black]] ; DEBUG
    
    ; show (list "index" index "node" current-node)
    if current-node = goal-node [
;      show "found"
;      ask goal-node [        show (list "goal-node says" parent g-score)      ] ;debug
      
      let path backtrace-path start-node goal-node
      
      report path
    ]
    
    set open-set (remove current-node open-set)
;    show (list "open-set" open-set)
    
    
    
    ask current-node [
      let current-poi one-of [meta-pois-here] of current-node
      let neighbor-meta-pois [pathable-neighbors] of current-poi
      let neighbor-nodes [patch-here] of neighbor-meta-pois
      let not-explored-neighbor-nodes filter [x -> member? x neighbor-nodes] open-set
;      show (list "neighbors" neighbor-nodes "not-explored" not-explored-neighbor-nodes)
      foreach not-explored-neighbor-nodes [ x -> 
        ask x [
          ask one-of meta-pois-here[ 
            let pathable-edge pathable-with current-poi
            let edge-distance [pathable-cost] of pathable-edge
            let alt [g-score] of current-node + edge-distance
;            show (list "edge-distance" edge-distance "alt" alt)
            if alt < g-score [
              set g-score alt
              set parent current-node
            ]
          ]
        ]
      ]
    ]
    
    ;    ask current-node [
    ;      let platform-neighbor-nodes p-platform-neighbors nodes
;      let not-explored-neighbor-nodes filter [x -> member? x platform-neighbor-nodes] open-set
;      show (list "neighbors" platform-neighbor-nodes "not-explored" not-explored-neighbor-nodes)
;      foreach not-explored-neighbor-nodes [ x -> 
;        ask x [
;          let edge-distance p-distance-platform current-node ; TODO change
;          let alt [g-score] of current-node + edge-distance
;          show (list "edge-distance" edge-distance "alt" alt)
;          if alt < g-score [
;            set g-score alt
;            set parent current-node
;          ]
;        ]
;      ]
;    ]
  ]
;  show "empty"
  report []
  
end

; observer
to show-pathfinding [start-vertex goal-vertex]
  let path p-pathfind start-vertex goal-vertex
  show-path path
end

; observer
to show-path [path]
  let index 0
  repeat length path - 1 [
    ask item index path [
      sprout-debugers 1 [
      set color red
      face item (index + 1) path
      ]
    ] 
  set index index + 1
  ]
  
  ask last path [
    sprout-debugers 1 [
      set color red
      set shape "flag"
    ] 
  ]
end

; observer
to show-walked-path [path]
  ask first path [
    sprout-debugers 1 [
      set color red
      pd
      let index 1
      repeat length path - 1 [
        let path-patch item index path
        move-to path-patch
        set index index + 1
      ]
    ]
  ]
  
end

; observer
to reset-show-paths
  ask debugers [die]
end

; observer
to init-normalized-paths
  let poi-turtles turtles with [member? tt TTS-PATHABLE]
  ask poi-turtles [
    let new-poi-paths []
    foreach poi-paths [
      poi-path ->
      let new-path normalize-path poi-path
      set new-poi-paths lput new-path new-poi-paths
    ]
    set poi-paths new-poi-paths
  ]
end

; observer
to-report normalize-path [path]
  if length path < 3 [
    report path
  ]
  let prev-patch item 0 path
  let new-path (list prev-patch)
  let cur-patch item 1 path
  let prev-vector from-to-vector prev-patch cur-patch
  let prev-direction vector-direction prev-vector
  
  let next-vector []
  let next-patch nobody
  
  let useful-path sublist path 2 length path
  let index-useful-path 0
  foreach useful-path[
    set next-patch item index-useful-path useful-path
    set next-vector from-to-vector cur-patch next-patch
    let is-adjacent adjacent cur-patch next-patch
    let next-direction vector-direction next-vector
    let is-same-direction prev-direction = next-direction
    ifelse is-adjacent and is-same-direction [
      ; Normalize the path
      set next-vector from-to-vector prev-patch cur-patch
    ]
    [
      ; Add to path
      set new-path lput cur-patch new-path
      set prev-vector from-to-vector cur-patch next-patch
      set prev-direction vector-direction prev-vector
    ]
    
    
    set index-useful-path index-useful-path + 1
    set cur-patch next-patch
    
  ]
  
  set new-path lput last useful-path new-path
  report new-path
end

to-report distance-path [path]
  let total-distance 0
  let index 0
  let prev-patch 0
  let next-patch 0
  repeat length path - 1 [
    set prev-patch item index path
    set next-patch item (index + 1) path
    ask prev-patch [
      set total-distance total-distance + distance next-patch
    ]
    set index index + 1 
  ]
  report total-distance
end

; observer
to-report p-pathfind-better [start-vertex goal-vertex]
  ask patches with [is-pathable] [
    set g-score infinity
    set h-score h-distance goal-vertex
    set f-score (g-score + h-score)
    set parent 0
  ]
  
  let open-set (list start-vertex)
  let closed-set []
  ask start-vertex [
    set g-score 0
    set f-score h-score
  ]
  
  while [length open-set > 0 ] [

    let current-vertex first sort-by[[t1 t2] -> [f-score] of t1 < [f-score] of t2] open-set
    show (list "current-vertex" current-vertex "->" [parent] of current-vertex)    
;    user-message (list "current-vertex" current-vertex "->" [parent] of current-vertex)    
    ask current-vertex [sprout-debugers 1 [set color black]] ; DEBUG
    
    if current-vertex = goal-vertex [ ; Goal reached
      let path backtrace-path start-vertex goal-vertex
      report path
    ]
    
    set open-set (remove current-vertex open-set)
    set closed-set lput current-vertex closed-set
    
    ask current-vertex [
      let pathable-neighbors neighbors with [
        is-pathable
      ]
;      ask pathable-neighbors
      ask neighbors4 with [is-pathable] ; BUG for some reason it's not working with the variable?
      [
        if not member? self closed-set [
          let tentative-g [g-score] of current-vertex + distance current-vertex
          let current-parent [parent] of current-vertex
          let new-parent current-vertex
          show (list "inside" self "neighbor of" current-vertex "->" current-parent)
;          user-message (list "inside" self "neighbor of" current-vertex "->" current-parent)
          if current-parent != 0 [
            if is-straight-path current-parent self [
              let new-tentative-g [g-score] of current-parent + distance current-parent
              if new-tentative-g <= tentative-g [
                set tentative-g new-tentative-g
                set new-parent current-parent
                show (list "found straighter path from" current-parent "to" self "instead of" current-vertex "->" current-parent)
;                user-message (list "found straighter path from" current-parent "to" self "instead of" current-vertex "->" current-parent)
              ]
            ]
          ]
          if not member? self open-set or tentative-g < g-score [
            set g-score tentative-g
            set f-score h-score + g-score
            set parent new-parent
            if not member? self open-set [
              set open-set lput self open-set
            ]
          ]
        ]
      ]
    ]
  ]
  show (list "couldn't find" start-vertex goal-vertex)
  report []
end

;; observer
;to-report get-straightened-parent [cur-parent to-straighten]
;  let pre-parent [parent] of cur-parent
;  let straightened false
;  while [not straightened] [
;    if pre-parent = 0 [
;      report cur-parent 
;    ]
;    ask to-straighten [
;      if is-straight-path pre-parent to-straighten [
;        let new-g distance pre-parent
;        let pre-g [g-score] of cur-parent + distance cur-parent
;        ifelse new-g <= pre-g [
;          set pre-parent [parent] of pre-parent
;        ]
;        [
;          set straightened true
;        ]
;      ]
;    ]
;  ]
;  report cur-parent
;end


; observer
to-report is-straight-path [start-vertex goal-vertex]
  let start-pos (list ([pxcor] of start-vertex) ([pycor] of start-vertex))
  let goal-pos (list ([pxcor] of goal-vertex) ([pycor] of goal-vertex))
  let is-straight is-straight-path-pos start-pos goal-pos
  report is-straight
end

; observer
to-report is-straight-path-pos [start-pos goal-pos]
  let goal-step-length 0.3
  let goal-vector subtract-vector goal-pos start-pos
  let goal-distance-squared distance-vector-squared goal-vector
  let normalized-goal-vector normalize-vector goal-vector
  let goal-step scale-vector normalized-goal-vector goal-step-length
  
;  show (list start-pos "->" goal-pos "vector" goal-vector "normalized vector" normalized-goal-vector "goal-step" goal-step)
  if does-intersect-turtle-pos-around start-pos [
    report false 
  ]
  if does-intersect-turtle-pos-around goal-pos [
    report false 
  ]
  let prev-pos start-pos
  while [true] [
    let cur-pos add-vector prev-pos goal-step
    let cur-vector subtract-vector cur-pos start-pos
    let cur-distance-squared distance-vector-squared cur-vector
;    show (list "cur pos" cur-pos "cur vector" cur-vector "cur-distance" sqrt cur-distance-squared "goal-distance" sqrt goal-distance-squared)
    if cur-distance-squared >= goal-distance-squared[
      ; overshot goal
      report true 
    ]
    
    if does-intersect-turtle-pos-around cur-pos [
      report false 
    ]
    set prev-pos cur-pos
;    show (list start-pos "-" cur-pos "->" goal-pos)
  ]
  report true
end






