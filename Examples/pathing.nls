; observer
to init-path-finding
  init-portals-pathfinding
  init-floors-pathfinding
end

; observer
to init-portals-pathfinding 
  
  ask portals [
    let p-a1 self
    let connected-portals other portals with [
      tfloor-x = [tfloor-x] of myself
      and 
      tfloor-y =  [tfloor-y] of myself
    ]
    ask connected-portals [
      create-access-with p-a1 [
        print (list "create access" p-a1 self myself)
        set a1 p-a1
        set a2 myself
        set p-cost 0 
        set color red 
      ] 
    ]
  ]
end

; observer
to init-floors-pathfinding
  let platforms-index 0
  repeat PLATFORMS [
    let path-found-turtles []
    let poi-turtles turtles with [member? tt TTS-PATHABLE and t-platform = platforms-index]
    let poi-turtles-with-no-paths poi-turtles with [init-poi-paths = false]
    print poi-turtles
    while [count poi-turtles-with-no-paths > 0 ][
      ask one-of poi-turtles-with-no-paths[
        let left-to-pathfind-to [self] of other poi-turtles-with-no-paths
        let index 0
        foreach left-to-pathfind-to [
          let goal item index left-to-pathfind-to
          show goal
          let path pathfind goal
          let normalized-path normalize-path path
          set poi-paths lput path poi-paths
          create-findable-with goal [
            set f1 myself
            set f2 goal
            set f-path normalized-path
            set f-p-id platforms-index
            set color green
          ]
          
          set index index + 1
        ]
        set init-poi-paths true
      ]
      set poi-turtles-with-no-paths poi-turtles with [init-poi-paths = false]
    ]
    set platforms-index platforms-index + 1
  ]
end

to-report adjacent [p1 p2]
  let p1-neighbors []
  ask p1 [
    set p1-neighbors neighbors
  ]
  report member? p2 p1-neighbors
end

; patch
to-report h-distance [destination-patch]
  report distance destination-patch
end

;patch
to-report is-pathable
  report not empty? filter [i -> member? i PTS-PATHABLE] pts
end

;patch
to-report backtrace-path [goal-vertex]
  let path []
  let current-vertex goal-vertex
  while [current-vertex != 0] [
    set path fput current-vertex path
    set current-vertex [parent] of current-vertex
  ]
  report path
end

; turtle
to-report pathfind [pathfind-to]
  ask debugers [die]
  let start-vertex patch-here
  let goal-vertex [patch-here] of pathfind-to
  ask patches with [is-pathable] [
    set g-score infinity
    set h-score h-distance goal-vertex
    set f-score (g-score + h-score)
    set parent 0
  ]
  
  let open-set (list start-vertex)
  let closed-set []
  ask start-vertex [
    set g-score 0
    set f-score h-score
  ]
  
  while [length open-set > 0 ] [
    let current-vertex first sort-by[[t1 t2] -> [f-score] of t1 < [f-score] of t2] open-set
    
    ask current-vertex [sprout-debugers 1 [set color black]]
    if current-vertex = goal-vertex [ ; Goal reached
      let path backtrace-path goal-vertex
      report path
    ]
    
    set open-set (remove current-vertex open-set)
    set closed-set lput current-vertex closed-set
    
    ask current-vertex [
      
      let pathable-neighbors neighbors with [
        is-pathable
      ]
      ask pathable-neighbors[
        if not member? self closed-set [
          let tentative-g [g-score] of current-vertex + distance current-vertex
          if not member? self open-set or tentative-g < g-score [
            set g-score tentative-g
            set f-score h-score + g-score
            set parent current-vertex
            if not member? self open-set [
              set open-set lput self open-set
            ]
          ]
        ]
      ]
    ]
  ]
  show (list "couldn't find" patch-here start-vertex goal-vertex)
  report []
end


; observer
to init-normalized-paths
  let poi-turtles turtles with [member? tt TTS-PATHABLE]
  ask poi-turtles [
    show ""
    let new-poi-paths []
    foreach poi-paths [
      poi-path ->
      let new-path normalize-path poi-path
      set new-poi-paths lput new-path new-poi-paths
    ]
    set poi-paths new-poi-paths
  ]
end

; observer
to-report normalize-path [path]
  if length path < 3 [
    report path
  ]
  let prev-patch item 0 path
  let new-path (list prev-patch)
  let cur-patch item 1 path
  let prev-vector from-to-vector prev-patch cur-patch
  let prev-direction vector-direction prev-vector
  
  let next-vector []
  let next-patch nobody
  
  let useful-path sublist path 2 length path
  let index-useful-path 0
  foreach useful-path[
    set next-patch item index-useful-path useful-path
    set next-vector from-to-vector cur-patch next-patch
    let is-adjacent adjacent cur-patch next-patch
    let next-direction vector-direction next-vector
    let is-same-direction prev-direction = next-direction
    ifelse is-adjacent and is-same-direction [
      ; Normalize the path
      set next-vector from-to-vector prev-patch cur-patch
    ]
    [
      ; Add to path
      set new-path lput cur-patch new-path
      set prev-vector from-to-vector cur-patch next-patch
      set prev-direction vector-direction prev-vector
    ]
    
    
    set index-useful-path index-useful-path + 1
    set cur-patch next-patch
    
  ]
  
  set new-path lput last useful-path new-path
  report new-path
  
end