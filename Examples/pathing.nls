; observer
to init-path-finding
  init-portals-pathfinding
  init-floors-pathfinding
end

; observer
to init-portals-pathfinding 
  
  ask portals [
    let p-a1 self
    let connected-portals other portals with [
      tfloor-x = [tfloor-x] of myself
      and 
      tfloor-y =  [tfloor-y] of myself
    ]
    ask connected-portals [
      create-access-with p-a1 [
        set a1 p-a1
        set a2 myself
        set p-cost 0 
        set color red 
      ] 
    ]
  ]
end

; observer
to init-floors-pathfinding
  let platforms-index 0
  repeat PLATFORMS [
    let path-found-turtles []
    let poi-turtles turtles with [member? tt TTS-PATHABLE and t-platform = platforms-index]
    let poi-turtles-with-no-paths poi-turtles with [init-poi-paths = false]
    while [count poi-turtles-with-no-paths > 0 ][
      ask one-of poi-turtles-with-no-paths[
        let left-to-pathfind-to [self] of other poi-turtles-with-no-paths
        let index 0
        foreach left-to-pathfind-to [
          let goal item index left-to-pathfind-to
          let path pathfind goal
          let normalized-path normalize-path path
          let normalized-path-cost distance-path normalized-path
          set poi-paths lput path poi-paths
          create-findable-with goal [
            set f1 myself
            set f2 goal
            set f-path normalized-path
            set f-cost normalized-path-cost
            set f-p-id platforms-index
            set color green
          ]
          
          set index index + 1
        ]
        set init-poi-paths true
      ]
      set poi-turtles-with-no-paths poi-turtles with [init-poi-paths = false]
    ]
    set platforms-index platforms-index + 1
  ]
end

; observer
to-report adjacent [p1 p2]
  let p1-neighbors []
  ask p1 [
    set p1-neighbors neighbors
  ]
  report member? p2 p1-neighbors
end

; patch
to-report h-distance [destination-patch]
  report distance destination-patch
end

; patch
to-report is-pathable
  report not empty? filter [i -> member? i PTS-PATHABLE] pts
end

; observer
to-report backtrace-path [start-vertex goal-vertex]
  let path []
  let current-vertex goal-vertex
  while [current-vertex != 0] [
    set path fput current-vertex path
    set current-vertex [parent] of current-vertex
  ]
  if first path != start-vertex [
    report [] 
  ]
  report path
end

; turtle
to-report pathfind [pathfind-to]
  ask debugers [die]
  let start-vertex patch-here
  let goal-vertex [patch-here] of pathfind-to
  report p-pathfind start-vertex goal-vertex
end

; observer
to-report p-pathfind [start-vertex goal-vertex]
  ask patches with [is-pathable] [
    set g-score infinity
    set h-score h-distance goal-vertex
    set f-score (g-score + h-score)
    set parent 0
  ]
  
  let open-set (list start-vertex)
  let closed-set []
  ask start-vertex [
    set g-score 0
    set f-score h-score
  ]
  
  while [length open-set > 0 ] [
    let current-vertex first sort-by[[t1 t2] -> [f-score] of t1 < [f-score] of t2] open-set
    
    ask current-vertex [sprout-debugers 1 [set color black]] ; DEBUG
    
    if current-vertex = goal-vertex [ ; Goal reached
      let path backtrace-path goal-vertex
      report path
    ]
    
    set open-set (remove current-vertex open-set)
    set closed-set lput current-vertex closed-set
    
    ask current-vertex [
      
      let pathable-neighbors neighbors with [
        is-pathable
      ]
      ask pathable-neighbors[
        if not member? self closed-set [
          let tentative-g [g-score] of current-vertex + distance current-vertex
          if not member? self open-set or tentative-g < g-score [
            set g-score tentative-g
            set f-score h-score + g-score
            set parent current-vertex
            if not member? self open-set [
              set open-set lput self open-set
            ]
          ]
        ]
      ]
    ]
  ]
  show (list "couldn't find" start-vertex goal-vertex)
  report []
end


; patch
to-report p-platform-neighbors [nodes]
  let neighbor-nodes 0
  ifelse any? portals-here [
    let portal-node one-of portals-here
    set neighbor-nodes nodes with [
      p-platform = [p-platform] of myself
      or
      member? portal-node access-neighbors 
    ]
  ]
  [
    set neighbor-nodes nodes with [
      p-platform = [p-platform] of myself 
    ]
  ]
  report neighbor-nodes
end 

; patch 
to-report p-distance-platform [destination-patch]
  let _distance 0
  ifelse p-platform = [p-platform] of destination-patch [
      ; normal pathfind
    let path p-pathfind self destination-patch
    set _distance distance-path path
  ][
    let destination-portal one-of [portals-here] of destination-patch
    set _distance [p-cost] of access-with destination-portal
  ]
  report _distance
end

; observer
; TODO test
to-report p-platform-pathfind [start-node goal-node]
  let nodes patches with [
    any? portals-here 
    or 
    self = start-node
    or 
    self = goal-node
  ] 
  
  ask nodes [
    set g-score infinity
    set parent 0 
  ]
  
  ask start-node [
    set g-score 0
  ]
  
  let open-set (list start-node)
  let closed-set []
  
  while [not empty? open-set ] [
    let current-node min-one-of open-set [g-score]
    ask current-node [sprout-debugers 1 [set color black]] ; DEBUG
    
    set open-set (remove current-node open-set)
    
    let platform-neighbor-nodes p-platform-neighbors nodes
    let not-explored-neighbor-nodes filter [x -> member? x platform-neighbor-nodes] open-set
    ask not-explored-neighbor-nodes [
      let edge-distance p-distance-platform current-node
      let alt [g-score] of current-node + edge-distance
      if alt < g-score [
        set g-score alt
        set parent current-node
      ]
    ]
    
    
    
  ]
  
  let path backtrace-path goal-node
  report path
  
end

; observer
to show-pathfinding [start-vertex goal-vertex]
  let path p-pathfind start-vertex goal-vertex
  show-path path
end

; observer
to show-path [path]
  let index 0
  repeat length path - 1 [
    ask item index path [
      sprout-debugers 1 [
      set color red
      face item (index + 1) path
      ]
    ] 
  set index index + 1
  ]
end

; observer
to reset-show-paths
  ask debugers [die]
end

; observer
to init-normalized-paths
  let poi-turtles turtles with [member? tt TTS-PATHABLE]
  ask poi-turtles [
    let new-poi-paths []
    foreach poi-paths [
      poi-path ->
      let new-path normalize-path poi-path
      set new-poi-paths lput new-path new-poi-paths
    ]
    set poi-paths new-poi-paths
  ]
end

; observer
to-report normalize-path [path]
  if length path < 3 [
    report path
  ]
  let prev-patch item 0 path
  let new-path (list prev-patch)
  let cur-patch item 1 path
  let prev-vector from-to-vector prev-patch cur-patch
  let prev-direction vector-direction prev-vector
  
  let next-vector []
  let next-patch nobody
  
  let useful-path sublist path 2 length path
  let index-useful-path 0
  foreach useful-path[
    set next-patch item index-useful-path useful-path
    set next-vector from-to-vector cur-patch next-patch
    let is-adjacent adjacent cur-patch next-patch
    let next-direction vector-direction next-vector
    let is-same-direction prev-direction = next-direction
    ifelse is-adjacent and is-same-direction [
      ; Normalize the path
      set next-vector from-to-vector prev-patch cur-patch
    ]
    [
      ; Add to path
      set new-path lput cur-patch new-path
      set prev-vector from-to-vector cur-patch next-patch
      set prev-direction vector-direction prev-vector
    ]
    
    
    set index-useful-path index-useful-path + 1
    set cur-patch next-patch
    
  ]
  
  set new-path lput last useful-path new-path
  report new-path
end

to-report distance-path [path]
  let total-distance 0
  let index 0
  let prev-patch 0
  let next-patch 0
  repeat length path - 1 [
    set prev-patch item index path
    set next-patch item (index + 1) path
    ask prev-patch [
      set total-distance total-distance + distance next-patch
    ]
    set index index + 1 
  ]
  report total-distance
end
