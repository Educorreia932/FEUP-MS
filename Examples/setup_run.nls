
globals [
  ; VARAIABLES
  number-passengers left-to-spawn
  
  number-pois
]

; observer
to setup-run-constants 
  set number-passengers 5

end

; observer
to setup-run
  init-runnables
  setup-run-constants
  setup-spawning
  ;  set left-to-spawn number-passengers
  ;  init-pois
  ;  init-passengers
  ask links [hide-link]
  
  foreach [self] of passengers [
    pass -> 
    reset-walked-paths
    ask pass [show-walked-path passenger-path]
    user-message ""
  ]
  reset-ticks
end

; observer
to init-runnables 
  ask train-cells [hide-turtle]
  ask trains [hide-turtle]
  ask passengers [die]
end

; observer
to setup-spawning
  let spawner-patches patches with [not empty? filter [i -> member? i PTS-DESTINY] pts]
    repeat number-passengers [
      ask one-of spawner-patches [
        let sprouted-passenger sprout-passenger
        ask sprouted-passenger [ 
        route-passenger 
        path-passenger
      ]
      ] 
    ]
end


; patch
to-report sprout-passenger 
  let collides true
  let sprouted-passenger 0
  let p self
  while [collides]
  [
    let random-x random-float 0.98 - 0.49 ; prevent passing to another patch due to roundings
    let random-y random-float 1 - 0.5
    let pass-x pxcor + random-x
    let pass-y pycor + random-y
    let pass-pos list pass-x pass-y
    if not does-intersect-turtle-pos-around pass-pos [
      set collides false
      sprout-passengers 1 [
        set size 0.5
        set shape "person"
        set color [100 255 255]
        setxy pass-x pass-y
        
        set spawned true
        set source-patch p
        set source [p-destination] of p
        
        set sprouted-passenger self
      ]  
    ]
  ]
  report sprouted-passenger
  
end

; passenger
to route-passenger 
  let pass-source source
  let all-train-destinations trains
  let all-destinations ( turtle-set  all-train-destinations)
  let other-destinations all-destinations with [
    self != pass-source
  ]
  
  let chosen-destination one-of other-destinations
  
  set destination chosen-destination
  
  let possible-destination-patches patches with [p-destination = chosen-destination]
  set destination-patch one-of possible-destination-patches
end 

; patch
to-report p-destination
  if not is-destiny [
    report 0
  ]
  if p-destiny = PT-TRAIN [
    let id p-train-line 
    let destiny-trains trains with [tt-id = id]
    report one-of destiny-trains
  ]
  report 0
  
end

; patch
to-report is-destiny
  report not empty? _p-destinies
end

to-report p-destiny 
  report first _p-destinies
end

; patch
to-report _p-destinies 
  report filter [i -> member? i PTS-DESTINY] pts
end

; passenger
to path-passenger
  let meta-path p-platform-pathfind source-patch destination-patch
  show meta-path
  set passenger-path meta-path
;  show-walked-path meta-path
  
end

to init-pois
  let poi-index 0
  repeat number-pois [
    print poi-index
    let side poi-index mod 2
    create-a-poi-in-side side
    set poi-index poi-index + 1
  ]
end

to create-a-poi-in-side [side]
  let x min-pxcor ; default left side
  if side = 1
  [
    set x max-pxcor
  ]
  create-a-poi x random-ycor
end
to create-a-poi [x y]
  create-pois 1 [
    set empty true
    set to-spawn []
    set to-despawn []
    setxy x y
    set shape "square"
    set color red
  ]
end

to init-passengers

  repeat number-passengers [
    let to-be-source one-of pois
    let to-be-destination one-of pois with [self != to-be-source]

    create-passengers 1 [
      set source to-be-source
      set destination to-be-destination
      set spawned false
      set color pink
      setxy [xcor] of source  [ycor] of source
    ]

  ]
  ask pois [
    set to-spawn passengers with [source = myself]
    set to-despawn passengers with [destination = myself]
  ]
end


to spawn-passenger
  set spawned true
end

to spawn-passengers
  if left-to-spawn = 0 [
    stop
  ]

  ask pois [
    ; TODO
    show list "passengers here:" passengers-here
    ifelse any? passengers-here with [spawned = true] [
      print list "self" self

    ]
    [
      if any? to-spawn with [spawned = false][
        print list "to be spanwed" passengers-here with [spawned = false]
        ask one-of to-spawn [
          spawn-passenger
        ]
        print "exiting pois"
      ]
    ]

  ]
  ;let passengers-to-spawn passengers with [spawned = false]
  ;print list "length" count passengers-to-spawn
  ;ask passengers-to-spawn [
  ;  ask source [
  ;   ifelse empty [
  ;       show "is empty"
  ;       set empty false
  ;     ]
  ;     [
  ;       show "is full"
  ;    ]
  ;  ]
  ; ]
end