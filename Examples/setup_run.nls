
globals [
  ; VARAIABLES
  ;PRE RUN
  number-passengers left-to-spawn
  
  number-pois
  
  
  ; RUN
  passenger-step collision-calculations-per-tick
  collision-radius
  collision-force-multiplier
  collision-epsilon
  ; infered
  true-collision-radius   collision-sigma ; equivalent, just nomenclature
]

; observer
to setup-run-constants 
  ; PRE RUN
  set number-passengers 1
  
  ; RUN
  set passenger-step 0.3
  set collision-calculations-per-tick 5
  
  ; Collision if other agent within turtle-radius + collision-radius
  ; If collision-radius <= turtle-radius, turtles must overlap for collision
  ; If collision-radius > turtle-radius, turtles collide even at a distance
  set collision-radius 0.15
  set collision-force-multiplier 0.4
  set collision-epsilon 0.05 ; not used
  
  ; inferred
  set true-collision-radius collision-radius + turtle-radius
  set collision-sigma collision-radius + turtle-radius
  
  if true-collision-radius >= 1[
    user-message "Collision detection compromised. Collision should only be able to take place within neighbors patches of a turtle" 
  ]
  
  
end

; observer
to setup-run
  clear-drawing
  init-runnables
  setup-run-constants
  setup-spawning
  ask links [hide-link]
  
  reset-ticks

end

; observer
to init-runnables 
  ask train-cells [hide-turtle]
  ask trains [hide-turtle]
  ask passengers [die]
end

; observer
to setup-spawning
  let spawner-patches patches with [not empty? filter [i -> member? i PTS-DESTINY] pts]
  repeat number-passengers [
    ask one-of spawner-patches [
      let sprouted-passenger sprout-passenger
      ask sprouted-passenger [ 
        route-passenger 
        path-passenger
      ]
    ] 
  ]
end


; patch
to-report sprout-passenger 
  let collides true
  let sprouted-passenger 0
  let p self
  while [collides]
  [
    let random-x random-float 0.98 - 0.49 ; prevent passing to another patch due to roundings
    let random-y random-float 1 - 0.5
    let pass-x pxcor + random-x
    let pass-y pycor + random-y
    let pass-pos list pass-x pass-y
    if not does-intersect-turtle-pos-around pass-pos [
      set collides false
      sprout-passengers 1 [
        set size turtle-size
        set shape turtle-shape
        set color [100 255 255]
        setxy pass-x pass-y
        
        set spawned true
        set reached-destination false
        set source-patch p
        set source [p-destination] of p
        
        set sprouted-passenger self
      ]  
    ]
  ]
  report sprouted-passenger
  
end

; passenger
to route-passenger 
  let pass-source source
  let all-train-destinations trains
  let all-destinations ( turtle-set  all-train-destinations)
  let other-destinations all-destinations with [
    self != pass-source
  ]
  
  let chosen-destination one-of other-destinations
  
  set destination chosen-destination
  
  let possible-destination-patches patches with [p-destination = chosen-destination]
  set destination-patch one-of possible-destination-patches
end 

; patch
to-report p-destination
  if not is-destiny [
    report 0
  ]
  if p-destiny = PT-TRAIN [
    let id p-train-line 
    let destiny-trains trains with [tt-id = id]
    report one-of destiny-trains
  ]
  report 0
  
end

; patch
to-report is-destiny
  report not empty? _p-destinies
end

to-report p-destiny 
  report first _p-destinies
end

; patch
to-report _p-destinies 
  report filter [i -> member? i PTS-DESTINY] pts
end

; passenger
to path-passenger
  let meta-path p-platform-pathfind source-patch destination-patch
  show meta-path
  set passenger-meta-path meta-path
  set passenger-meta-path-index 0
  set passenger-simple-path-index 0
  set passenger-move-delay 0
  
  show-meta-walked-path meta-path ;DEBUG
  show "leaving path-pasenger"
end

to init-pois
  let poi-index 0
  repeat number-pois [
    print poi-index
    let side poi-index mod 2
    create-a-poi-in-side side
    set poi-index poi-index + 1
  ]
end

to create-a-poi-in-side [side]
  let x min-pxcor ; default left side
  if side = 1
  [
    set x max-pxcor
  ]
  create-a-poi x random-ycor
end
to create-a-poi [x y]
  create-pois 1 [
    set empty true
    set to-spawn []
    set to-despawn []
    setxy x y
    set shape "square"
    set color red
  ]
end

to init-passengers

  repeat number-passengers [
    let to-be-source one-of pois
    let to-be-destination one-of pois with [self != to-be-source]

    create-passengers 1 [
      set source to-be-source
      set destination to-be-destination
      set spawned false
      set color pink
      setxy [xcor] of source  [ycor] of source
    ]

  ]
  ask pois [
    set to-spawn passengers with [source = myself]
    set to-despawn passengers with [destination = myself]
  ]
end


to spawn-passenger
  set spawned true
end

to spawn-passengers
  if left-to-spawn = 0 [
    stop
  ]

  ask pois [
    ; TODO
    show list "passengers here:" passengers-here
    ifelse any? passengers-here with [spawned = true] [
      print list "self" self

    ]
    [
      if any? to-spawn with [spawned = false][
        print list "to be spanwed" passengers-here with [spawned = false]
        ask one-of to-spawn [
          spawn-passenger
        ]
        print "exiting pois"
      ]
    ]

  ]
  ;let passengers-to-spawn passengers with [spawned = false]
  ;print list "length" count passengers-to-spawn
  ;ask passengers-to-spawn [
  ;  ask source [
  ;   ifelse empty [
  ;       show "is empty"
  ;       set empty false
  ;     ]
  ;     [
  ;       show "is full"
  ;    ]
  ;  ]
  ; ]
end