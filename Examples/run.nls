
to go
  print "tick" 
  move-passengers
  ;  collide-passengers
  ;  repel-passengers-from-wall
  ;  update-passengers-path 
  tick
  
end

to setup-tests
  reset-ticks
  setup-run-constants 
  set turtle-size 1
  set turtle-shape "circle"
  set turtle-radius 1
  
  ask passengers[die]
end

to add-to-test
  ask patch 12 14 [let _ sprout-passenger]
end

to move-passengers
  ask moving-passengers [    
    ; Get destination (assume indexs are alright)
    let platform-path item passenger-meta-path-index passenger-meta-path
    let next-destination item passenger-simple-path-index platform-path
    
    ifelse passenger-move-delay > 0 [
      set passenger-move-delay passenger-move-delay - passenger-step ; Might be negative but that's alright
    ]
    [
      ; Move
      face next-destination
      fd passenger-step
      
      ;TODO prevent bumping against wall?
      
      ; Update path
      
      ; TODO
      ; check if destination is "good enough" at least when it comes to portals.
      ; Maybe, have destination as a temp variable, and allow it to change in case of crowdeness
      if patch-here = next-destination [  
        set passenger-simple-path-index passenger-simple-path-index + 1
        if passenger-simple-path-index >= length platform-path [
          set passenger-simple-path-index 0
          set passenger-meta-path-index passenger-meta-path-index + 1
          ifelse passenger-meta-path-index >= length passenger-meta-path [
            set reached-destination true
          ]
          [
            ; check for portal access path
            set platform-path item passenger-meta-path-index passenger-meta-path
            if length platform-path = 2 [
              let platform-path-from item 0 platform-path
              if [p-is-portal?] of platform-path-from [
                ; from is portal
                let platform-path-from-portal one-of [portals-here] of platform-path-from 
                ask platform-path-from-portal [
                  let platform-path-to item 1 platform-path
                  if [p-is-portal?] of platform-path-to [
                    ; to is portal  
                    let platform-path-to-portal one-of [portals-here] of platform-path-to
                    let portals-access access-with platform-path-to-portal
                    if portals-access != nobody [
                      ; the meta-path uses the portals
                      set passenger-move-delay [p-cost] of portals-access 
                      set passenger-meta-path-index passenger-meta-path-index + 1
                    ]
                  ]
                ]
              ]
            ]
          ]
        ]
      ]
    ]
  ]
end

to collide-passengers
  repeat collision-calculations-per-tick [
    ; calculate collision-vectors
    ask moving-passengers [
      set sum-collisions-vector (list 0 0) 
      let self-x xcor
      let self-y ycor
      let possible-collision-around-passengers [passengers-here] of neighbors 
      let possible-collision-here-passenger other [passengers-here] of patch-here 
      let possible-collision-passengers (turtle-set possible-collision-around-passengers possible-collision-here-passenger)
      let collision-passengers possible-collision-passengers in-radius true-collision-radius
      let sum-x 0
      let sum-y 0
      ask collision-passengers [
        let d-x abs self-x - xcor 
        let d-y abs self-y - ycor 
        let collision-vector (list d-x d-y)
        let _repel-vector repel-vector collision-vector
;        let overlap-collision-vector subtract-magnitude-from-vector collision-vector true-collision-radius
;        let force-x item 0 overlap-collision-vector
;        let force-y item 1 overlap-collision-vector
;        set force-x d-x
;        set force-y d-y
        let force-x item 0 _repel-vector
        let force-y item 1 _repel-vector 
        
        
        set sum-x sum-x + force-x
        set sum-y sum-y + force-y
;        show (list "    original collision" collision-vector "overlap collision" _repel-vector "sum-x sum-y" sum-x sum-y)
      ]
      let sum-force-x collision-force-multiplier * sum-x
      let sum-force-y collision-force-multiplier * sum-y
      let all-collisions-vector (list sum-force-x sum-force-y)
      let crowdness-proportional-collisions-vector scale-vector all-collisions-vector ( 1 / ( count collision-passengers + 1))
      set sum-collisions-vector crowdness-proportional-collisions-vector
;      show (list "original sum-x sum-y" sum-x sum-y "multiplied force" sum-force-x sum-force-y)
    ]
    ; apply collision-vectors
    ask moving-passengers [
      let d-x item 0 sum-collisions-vector
      let d-y item 1 sum-collisions-vector
;      show (list "changing coors from " xcor ycor "to " (xcor + d-x) (ycor + d-y ))
      
      ; using clamp while repel force is not very well established, and map with no borders
      let new-x clamp (xcor + d-x) 0 ( world-width + 1)
      let new-y clamp (ycor + d-y) 0 ( world-height + 1)
      set xcor new-x
      set ycor new-y
    ]
  ]
end


to repel-passengers-from-wall
  
end

to update-passengers-path
  
end

to-report moving-passengers
   report passengers with [not reached-destination]
end