
to go
  move-passengers
  collide-passengers
  repel-passengers-from-wall
  log-passengers-tick
  update-passengers-path 
    
  ifelse count moving-passengers = 0 [
    if first-end [
      show "REACHED END"
      set first-end false 
      
      log-reached-end
      
      ; save-logs
      save-digestable-logs
    ]
  ]
  [
    tick  
  ]
end

to setup-tests
  init-runnables
  setup-run-constants 
  ;  set turtle-size 1
  ;  set turtle-shape "circle"
  ;  set turtle-radius 1
  ask links [hide-link]
  
  clear-drawing
  reset-ticks
end

to add-to-test
  ask patch 12 14 [let _ sprout-passenger]
end

to add-to-test-2
  ask patch 18 19 [
    let p self
    let random-x random-float 0.98 - 0.49 ; prevent passing to another patch due to roundings
    let random-y random-float 1 - 0.5
    let pass-x pxcor + random-x
    let pass-y pycor + random-y
    let pass-pos list pass-x pass-y
    
    sprout-passengers 1 [
      set size 0.05
      set shape turtle-shape
      set color [100 255 255]
      setxy pass-x pass-y
      show (list "spawned at" xcor ycor)
      set reached-destination false
      
    ]
    
  ]
end

to add-to-test-3
  let spawner-patches patches with [not empty? filter [i -> member? i PTS-DESTINY] pts]
  
  ask one-of spawner-patches [
    let sprouted-passenger sprout-passenger
    ask sprouted-passenger [ 
      route-passenger 
      path-passenger
      
    ] 
  ]
  
end

to add-to-test-instance-3-1
  add-to-test-instance-3 11.427096876777567 1.6919347185794718 patch 24 21
end

to add-to-test-instance-3-2
  add-to-test-instance-3 15 1 patch 4 14
end

to add-to-test-instance-3-3
  add-to-real-test-instance 9 28 patch 12 3
end 

to add-to-test-instance-3-4
  add-to-real-test-instance 52 4 patch 43 29
end 

to add-to-real-test-instance [x y pp]
  ask patch x y [
    let sprouted-passenger sprout-passenger
    ask sprouted-passenger [
      let destination-train 0
      ask pp[
        let train-index position PT-TRAIN pts
        let train_id item train-index pts-ids
        set destination-train one-of trains with [tt-id = train_id and tt = TT-POI]
      ]
      show ( list "destination" destination-train )
      set destination destination-train
      set destination-patch pp
      path-passenger
    ]
  ]
  
  
end

to add-to-test-instance-3 [x y pp]
  
  ask patch x y [
    let sprouted-passenger 0
    let p self
    
    sprout-passengers 1 [
      set size turtle-size
      set shape turtle-shape
      set color [100 255 255]
      setxy x y
      
      set spawned true
      set reached-destination false
      set source-patch p
      set source [p-destination] of p
      
      set sprouted-passenger self
      
      let pass-source source
      let all-train-destinations trains
      let all-destinations ( turtle-set  all-train-destinations)
      let other-destinations all-destinations with [
        self != pass-source
      ]
      
      let chosen-destination one-of other-destinations
      
      set destination [belong-to-train] of [train-cells-here] of pp
      set destination-patch pp
      
      let meta-path p-platform-pathfind source-patch destination-patch
      show meta-path
      set passenger-meta-path meta-path
      set passenger-meta-path-index 0
      set passenger-simple-path-index 0
      set passenger-move-delay 0
      
      show-meta-walked-path meta-path ;DEBUG
      show "leaving path-pasenger META PATH IS BAD"
    ]  
  ]  
end


; observer
to move-passengers
  ask moving-passengers [    
    let next-destination get-next-destination
    
    ifelse passenger-move-delay > 0 [
      set passenger-move-delay passenger-move-delay - 1 ; Might be negative but that's alright
    ]
    [
      ; Move
      face next-destination
      
      ifelse [is-up-esc] of patch-here or [is-down-esc] of patch-here [
        fd passenger-step * escalator-speed-multiplier 
      ]
      [
        fd passenger-step
      ]
    ]
  ]
end

to collide-passengers
  repeat collision-calculations-per-tick [
    ; calculate collision-vectors
    ask moving-passengers [
      set sum-collisions-vector (list 0 0) 
      let self-x xcor
      let self-y ycor
      
      ;triaging
      let possible-collision-around-passengers [passengers-here] of neighbors
      let possible-collision-here-passenger other [passengers-here] of patch-here 
      let possible-collision-passengers (turtle-set possible-collision-around-passengers possible-collision-here-passenger)
      ; end triaging
      set possible-collision-passengers moving-passengers-set possible-collision-passengers


      let collision-passengers possible-collision-passengers in-radius true-collision-radius
      let sum-x 0
      let sum-y 0
      ask collision-passengers [
        let d-x abs self-x - xcor 
        let d-y abs self-y - ycor 
        let collision-vector (list d-x d-y)
        let _repel-vector repel-vector collision-vector
        ;        let overlap-collision-vector subtract-magnitude-from-vector collision-vector true-collision-radius
        ;        let force-x item 0 overlap-collision-vector
        ;        let force-y item 1 overlap-collision-vector
        ;        set force-x d-x
        ;        set force-y d-y
        let force-x item 0 _repel-vector
        let force-y item 1 _repel-vector 
        
        
        set sum-x sum-x + force-x
        set sum-y sum-y + force-y
        ;        show (list "    original collision" collision-vector "overlap collision" _repel-vector "sum-x sum-y" sum-x sum-y)
      ]
      let sum-force-x collision-force-multiplier * sum-x
      let sum-force-y collision-force-multiplier * sum-y
      let all-collisions-vector (list sum-force-x sum-force-y)
      let crowdness-proportional-collisions-vector scale-vector all-collisions-vector ( 1 / ( count collision-passengers + 1))
      set sum-collisions-vector crowdness-proportional-collisions-vector
      ;      show (list "original sum-x sum-y" sum-x sum-y "multiplied force" sum-force-x sum-force-y)
    ]
    ; apply collision-vectors
    ask moving-passengers [
      let d-x item 0 sum-collisions-vector
      let d-y item 1 sum-collisions-vector
      ;      show (list "changing coors from " xcor ycor "to " (xcor + d-x) (ycor + d-y ))
      
      ; using clamp while repel force is not very well established, and map with no borders
      let new-x clamp (xcor + d-x) 0 ( world-width + 1)
      let new-y clamp (ycor + d-y) 0 ( world-height + 1)
      set xcor new-x
      set ycor new-y
    ]
  ]
end


to repel-passengers-from-wall
  ask moving-passengers [
    if not ( [is-pathable] of patch-here ) [
      ; is in wall
      let passenger-in-wall self
      let passenger-pos (list xcor ycor)
      
      ; find closest patch to repel to
      let possible-repel-patches ( [neighbors] of patch-here ) with [is-pathable]
      let closest-repel min-one-of possible-repel-patches [distance passenger-in-wall]
      
      
      let in-wall-vector get-turtle-pos-patch-closest-vector passenger-pos closest-repel ; find the minimal vector that represents how inside the wall passenger is
      let repel-to-wall-border-vector symmetric-vector in-wall-vector ; repel vector is the symmetric of the inside wall vector
      let repel-from-border-vector scale-vector ( normalize-vector repel-to-wall-border-vector ) wall-collision-repel ; add some margin to get away from wall
      let ensure-patch-repel-vector add-vector repel-to-wall-border-vector repel-from-border-vector
      
      let d-x item 0 ensure-patch-repel-vector
      let d-y item 1 ensure-patch-repel-vector
      
      let new-x xcor + d-x
      let new-y ycor + d-y
      
      setxy new-x new-y
    ]
  ]
end

to update-passengers-path
  ask moving-passengers [
    ; Update path
    let this-passenger self
    let platform-path get-next-path
    let next-destination get-next-destination
    ifelse patch-here = next-destination [  
      set passenger-simple-path-index passenger-simple-path-index + 1
      if passenger-simple-path-index >= length platform-path [
        set passenger-simple-path-index 0
        set passenger-meta-path-index passenger-meta-path-index + 1
        ifelse passenger-meta-path-index >= length passenger-meta-path [
          set reached-destination true
        ]
        [
          ; check for portal access path
          set platform-path item passenger-meta-path-index passenger-meta-path
          if length platform-path = 2 [
            let platform-path-from item 0 platform-path
            if [p-is-portal?] of platform-path-from [
              ; from is portal
              let platform-path-from-portal one-of [portals-here] of platform-path-from 
              ask platform-path-from-portal [
                let platform-path-to item 1 platform-path
                if [p-is-portal?] of platform-path-to [
                  ; to is portal  
                  let platform-path-to-portal one-of [portals-here] of platform-path-to
                  ;                  show "both are portals"
                  let portals-access access-with platform-path-to-portal
                  ;                  show (list "access" portals-access)
                  if portals-access != nobody [
                    ; the meta-path uses the portals
                    ask this-passenger [
                      set passenger-move-delay [p-cost] of portals-access 
                      set passenger-meta-path-index passenger-meta-path-index + 1
                      let px [pxcor] of patch-here
                      let py [pycor] of patch-here
                      let d_x xcor - px
                      let d_y ycor - py
                      move-to platform-path-to-portal
                      set xcor xcor + d_x
                      set ycor ycor + d_y
                      
                      ; log portal transition
                      let this-tick-data last p-tick-data
                      let tick-data-length length p-tick-data
                      let this-tick-data-pos item 2 this-tick-data
                      let new-label [tt] of platform-path-from-portal
                      let new-pos-info pos-info (list xcor ycor)
                      set this-tick-data-pos replace-item 1  this-tick-data-pos new-label
                      set this-tick-data-pos replace-item 2  this-tick-data-pos new-pos-info
                      set this-tick-data replace-item 2 this-tick-data this-tick-data-pos
                      set p-tick-data replace-item  ( tick-data-length - 1 ) p-tick-data this-tick-data
                    ]
                  ]
                ]
              ]
            ]
          ]
        ]
      ]
    ][
      ; TODO
      ; check if destination is "good enough" at least when it comes to portals.
      ; Maybe, have destination as a temp variable, and allow it to change in case of crowdeness
      
    ]
  ]
end

; passenger
to-report get-next-path 
  let next-path item passenger-meta-path-index passenger-meta-path
  report next-path
end

; passenger
to-report get-next-destination 
  ; Get destination (assume indexs are alright (within bounds and updated)
  let platform-path get-next-path
  let next-destination item passenger-simple-path-index platform-path
  report next-destination
end

to-report moving-passengers
  report passengers with [not reached-destination]
end

to-report moving-passengers-set [passengers-set]
  report passengers-set with [not reached-destination]
end

; observer
to-report pos-info [pos] 
  let abs-x item 0 pos
  let abs-y item 1 pos
  let p patch abs-x abs-y
  let floor-id [pfloor-id] of p
  let floor-x [pfloor-x] of p
  let floor-y [pfloor-y] of p
  let platform [p-platform] of p
  report (list abs-x abs-y floor-id platform floor-x floor-y)
end

; passenger 
to log-passenger-tick
  let biggest-radius-multiplier last LOG-CROWDNESS-RADII 
  let biggest-radius biggest-radius-multiplier * true-collision-radius
  let possible-passengers-in-radius other moving-passengers
  let passengers-in-biggest-radius possible-passengers-in-radius in-radius biggest-radius
  
  let crowdnesses []
  let radii-index 0
  while [radii-index < length LOG-CROWDNESS-RADII - 1] [
    let new-radius-multiplier item radii-index LOG-CROWDNESS-RADII
    let new-radius new-radius-multiplier * true-collision-radius
    let passengers-in-new-radius passengers-in-biggest-radius in-radius new-radius
    let count-passengers-in-new-radius count passengers-in-new-radius
    set crowdnesses lput count-passengers-in-new-radius crowdnesses
    set radii-index radii-index + 1
  ]
  set crowdnesses lput count passengers-in-biggest-radius crowdnesses
  
  let data (list who ticks (list pos-info (list xcor ycor) "none" pos-info (list xcor ycor)) heading crowdnesses)
  set p-tick-data lput data p-tick-data
end
to log-passengers-tick
  if LOG-DATA [
    ask moving-passengers [
      log-passenger-tick
    ] 
  ]
end

to log-reached-end 
  if LOG-DATA [
    ask passengers [
    set p-end-data []
    ]
    
    set end-data []
  ]
end